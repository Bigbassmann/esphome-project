espnow:
  on_receive:
    then:
      - lambda: |-
          std::string received_str(reinterpret_cast<const char *>(data), size);
          // Trim any trailing nulls or whitespace (optional but safe)
          received_str.erase(std::find_if(received_str.rbegin(), received_str.rend(), [](unsigned char ch) { return !std::isspace(ch) && ch != '\0'; }).base(), received_str.end());
          std::string sender_str = format_mac_address_pretty(info.src_addr);
          
          ESP_LOGI("espnow", "Raw packet received, size %d: %s", size, received_str.c_str());  // TEMP: Debug log to confirm lambda runs
          
          if (received_str.find("W:", 0) == 0) {  // FIXED: Use find instead of rfind
            id(received_weather_global) = received_str.substr(2);
            ESP_LOGI("espnow", "Received: %s from %s", id(received_weather_global).c_str(), sender_str.c_str());
            id(display1).update();  // Update display if present
            id(weather_trend_display).update();  // Force sensor update
          }
          
globals:
  - id: received_weather_global
    type: std::string
    restore_value: yes # Optional: Persist across reboots
    initial_value: '"Calibrating..."' # Matches sender's initial state (uncommented for default value)

text_sensor:
  - platform: template
    name: "AQ Weather Trend Rec'd"
    id: weather_trend_display # Use this ID to replace the local weather_trend
#    internal: true
    lambda: 'return id(received_weather_global);'
    update_interval: 30s # Poll the global periodically; adjust to match sender